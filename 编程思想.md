



### int数据溢出



```java
//MAX_VALUE
Integer.MAX_VALUE;//2147483647
Integer.MAX_VALUE+1;//-2147483648
Integer.MAX_VALUE+2;//-2147483647
//MIN_VALUE
Integer.MIN_VALUE;//-2147483648
Integer.MIN_VALUE-1;//2147483647
Integer.MIN_VALUE-2;//2147483646
```

```java
/*eg:1*/
int num = 2147483647 ;
num += 2L ; //+=运算符在eg:2中做个一个类型转换，相当于num = (int)(num + 2L);
System.out.println(num) ; 
-2147483647

/*eg:2*/
int num = 2147483647 ;
num = num + 2L ;  //在此处Error:(9, 19) java: 不兼容的类型: 从long转换到int可能会有损失
System.out.println(num) ;

/*eg:3*** 与eg:1实现的过程相同*/
int num = 2147483647 ;
long numB =(int)(2147483649L) ;
System.out.println(numB) ;
-2147483647
```

#### 使用Long类型解决int类型的溢出(数据类型由小变大)

- 问题1：程序的执行顺序都是从等号的右边到左边,Integer.MAX_VALUE+1先计算，得出结果 -2147483648赋值给num，所以num值依旧为-2147483648
  ```java
  long num=Integer.MAX_VALUE+1;
  -2147483648
  ```
  

最简单的做法是将其中一个变量首先做类型的扩充。扩充有两种实现方式

- 将int的数据变量赋值给long
  
    ```java
            long num=Integer.MAX_VALUE;
    //num是long类型+1为int类型=long类型
    		num=num+1;
            System.out.println(num+1);
    2147483648
    ```
  
  - 直接将等号右侧某个int类型变为long类型
  
    ​	 long类型+int类型=long类型
  
    ```java
    long num=(long)Integer.MAX_VALUE+1;
    System.out.println(num);
    2147483648
    ```

#### 数据类型由大变小(强制转换，可能会丢失内容)

```java
long num=2147483647;
//但如果数字超过Integer.MAX_VALUE，即2147483647，则需要在数字后面加上'L'或'l'
long num=2147483648L;
/************************/

long num=2147483648L;
int temp=(int)num;
System.out.println(temp);
-2147483648
```

- 范围小的数据类型可以自动变为范围大的数据类型
- 数据范围大的数据类型只有强制转换才能变为数据范围小的数据类型

### 基本数据类型默认值问题

​		基本数据类型都有其默认值，但是这个默认值在方法的声明中（主方法）无效

```java
public class DataOverflow {
    public static void main(String args[]) {
        int num;
        System.out.println(num);
    }
}
//Error:(9, 28) java: 可能尚未初始化变量num
```

- 1：在使用变量前进行赋值
- 2：在初始化赋值

### 选择题

*下面关于Java程序编写描述正确的一项是？* B

A. Java程序直接利用javac.exe命令就可以直接运行程序

B. 一个Java文件中可以定义有多个class声明，并且类名称可以与文件名称同名

C. 一个Java文件可以使用public class定义多个程序类

D. Java文件的后缀必须使用“*.javac”



### ++i与i++



- ++i,先进行自增，后进行运算
- i++,先进行运算，后进行自增

```java
int num = 50 ;
num = num ++ * 2 ;//在这里进行运算，50*2=100，num=100，而等号右侧的num++中的num则作为临时变量，不会影响外部的num变量
System.out.println(num) ;
```

```java
class Happy {
	public static void main(String args[]) {
      int i = 1 ;    
      int j = i++ ;
      if((i==(++j))&&((i++)==j)){
           i += j ;
       }
       System.out.println("i = "+i);
     }
}
5
```



### instanceof

　instanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例，用法为：

```java
`boolean` `result = obj ``instanceof` `Class`
```

　　其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。

　　注意：编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。

- obj 必须为引用类型，不能是基本类型

  ```java
  int i = 0;
  System.out.println(i instanceof Integer);//编译不通过
  System.out.println(i instanceof Object);//编译不通过
  ```

- obj 为 null

  ```java
  `System.out.println(``null` `instanceof` `Object);``//false`
  ```

  　　关于 null 类型的描述在官方文档：https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.1 有一些介绍。一般我们知道Java分为两种数据类型，一种是基本数据类型，有八个分别是 byte  short  int  long  float  double  char boolean,一种是引用类型，包括类，接口，数组等等。而Java中还有一种特殊的 null 类型，该类型没有名字，所以不可能声明为 null 类型的变量或者转换为 null 类型，null 引用是 null 类型表达式唯一可能的值，null 引用也可以转换为任意引用类型。我们不需要对 null 类型有多深刻的了解，我们只需要知道 null 是可以成为任意引用类型的**特殊符号**。

  　　在 [JavaSE规范](https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.20.2) 中对 instanceof 运算符的规定就是：如果 obj 为 null，那么将返回 false。

### static与final



# 继承

## 子类不能直接访问父类的私有属性

首先子类是无法继承父类的私有属性，也无法直接访问父类的私有属性。

但如果父类中有对私有属性的get和set的方法，而且是public的修饰的方法，

子类在继承父类的同时，也继承了带有public修饰的set和get方法，所以可以通过以下方式子类可以访问到父类的私有属性。



子类继承父类的所有的非私有的方法和属性。当父类的方法或属性被声明为private（私有的）时，子类是不可以继承的。



子类继承父类的注意事项：

1、在子类中可以继承父类的哪些东西，哪些不可以继承

父类中public、protected修饰的属性和方法可以继承，private修饰的属性和方法不能被继承

2、规则：创建子类对象的时候，首先调用的是父类的无参构造方法创建一个父类对象

3、可以在子类中显示调用父类的有参构造方法

4、如果父类的属性均为private修饰，则可以通过共有的getter、setter方法来调用

# 反射机制





# 函数式接口



# 统一异常处理

利用SpringMVC中的@ControllerAdvice实现统一异常处理

也可