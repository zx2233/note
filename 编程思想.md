

### 数据提升

对基本数据类型执行算数运算或按位运算，只要类型比int小(即char、byte、short)，那么在运算之前，这些值会自动转换为int。这样一来最终生成的结果就是int类型。如果想把结果赋值给较小的类型，就必须使用类型转换。

通常表达式中出现的最大的数据类型决定了表达式最终结果的数据类型。

如 float*double，结果就是double

### int数据溢出

#### 窄化转换

窄化转换（**将能容纳更多信息的数据类型转换成无法容纳那么多信息的类型**）会面临信息丢失的危险，此时编译器会强制我们进行类型转换。

#### 扩展转换

不必显示的进行类型转换，因为新类型肯定能容纳原来类型的信息，不会造成任何信息的丢失。



```java
//MAX_VALUE
Integer.MAX_VALUE;//2147483647
Integer.MAX_VALUE+1;//-2147483648
Integer.MAX_VALUE+2;//-2147483647
//MIN_VALUE
Integer.MIN_VALUE;//-2147483648
Integer.MIN_VALUE-1;//2147483647
Integer.MIN_VALUE-2;//2147483646
```

```java
/*eg:1*/
int num = 2147483647 ;
num += 2L ; //+=运算符在eg:2中做个一个类型转换，相当于num = (int)(num + 2L);
System.out.println(num) ; 
-2147483647

/*eg:2*/
int num = 2147483647 ;
num = num + 2L ;  //在此处Error:(9, 19) java: 不兼容的类型: 从long转换到int可能会有损失
System.out.println(num) ;

/*eg:3*** 与eg:1实现的过程相同*/
int num = 2147483647 ;
long numB =(int)(2147483649L) ;
System.out.println(numB) ;
-2147483647
```

#### 使用Long类型解决int类型的溢出(数据类型由小变大)

- 问题1：程序的执行顺序都是从等号的右边到左边,Integer.MAX_VALUE+1先计算，得出结果 -2147483648赋值给num，所以num值依旧为-2147483648
  ```java
  long num=Integer.MAX_VALUE+1;
  -2147483648
  ```
  

最简单的做法是将其中一个变量首先做类型的扩充。扩充有两种实现方式

- 将int的数据变量赋值给long
  
    ```java
            long num=Integer.MAX_VALUE;
    //num是long类型+1为int类型=long类型
    		num=num+1;
            System.out.println(num+1);
    2147483648
    ```
  
  - 直接将等号右侧某个int类型变为long类型
  
    ​	 long类型+int类型=long类型
  
    ```java
    long num=(long)Integer.MAX_VALUE+1;
    System.out.println(num);
    2147483648
    ```

#### 数据类型由大变小(强制转换，可能会丢失内容)

```java
long num=2147483647;
//但如果数字超过Integer.MAX_VALUE，即2147483647，则需要在数字后面加上'L'或'l'
long num=2147483648L;
/************************/

long num=2147483648L;
int temp=(int)num;
System.out.println(temp);
-2147483648
```

- 范围小的数据类型可以自动变为范围大的数据类型
- 数据范围大的数据类型只有强制转换才能变为数据范围小的数据类型

### 基本数据类型默认值问题

​		基本数据类型都有其默认值，但是这个默认值在方法的声明中（主方法）无效

```java
public class DataOverflow {
    public static void main(String args[]) {
        int num;
        System.out.println(num);
    }
}
//Error:(9, 28) java: 可能尚未初始化变量num
```

- 1：在使用变量前进行赋值
- 2：在初始化赋值

### 选择题

*下面关于Java程序编写描述正确的一项是？* B

A. Java程序直接利用javac.exe命令就可以直接运行程序

B. 一个Java文件中可以定义有多个class声明，并且类名称可以与文件名称同名

C. 一个Java文件可以使用public class定义多个程序类

D. Java文件的后缀必须使用“*.javac”



### ++i与i++



- ++i,先进行自增，后进行运算
- i++,先进行运算，后进行自增

```java
int num = 50 ;
num = num ++ * 2 ;//在这里进行运算，50*2=100，num=100，而等号右侧的num++中的num则作为临时变量，不会影响外部的num变量
System.out.println(num) ;
```

```java
class Happy {
	public static void main(String args[]) {
      int i = 1 ;    
      int j = i++ ;
      if((i==(++j))&&((i++)==j)){
           i += j ;
       }
       System.out.println("i = "+i);
     }
}
5
```



### instanceof

　instanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例，用法为：

```java
`boolean` `result = obj ``instanceof` `Class`
```

　　其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。

　　注意：编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。

- obj 必须为引用类型，不能是基本类型

  ```java
  int i = 0;
  System.out.println(i instanceof Integer);//编译不通过
  System.out.println(i instanceof Object);//编译不通过
  ```

- obj 为 null

  ```java
  `System.out.println(``null` `instanceof` `Object);``//false`
  ```

  　　关于 null 类型的描述在官方文档：https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.1 有一些介绍。一般我们知道Java分为两种数据类型，一种是基本数据类型，有八个分别是 byte  short  int  long  float  double  char boolean,一种是引用类型，包括类，接口，数组等等。而Java中还有一种特殊的 null 类型，该类型没有名字，所以不可能声明为 null 类型的变量或者转换为 null 类型，null 引用是 null 类型表达式唯一可能的值，null 引用也可以转换为任意引用类型。我们不需要对 null 类型有多深刻的了解，我们只需要知道 null 是可以成为任意引用类型的**特殊符号**。

  　　在 [JavaSE规范](https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.20.2) 中对 instanceof 运算符的规定就是：如果 obj 为 null，那么将返回 false。

### static与final



# 继承

## 子类不能直接访问父类的私有属性

首先子类是无法继承父类的私有属性，也无法直接访问父类的私有属性。

但如果父类中有对私有属性的get和set的方法，而且是public的修饰的方法，

子类在继承父类的同时，也继承了带有public修饰的set和get方法，所以可以通过以下方式子类可以访问到父类的私有属性。



子类继承父类的所有的非私有的方法和属性。当父类的方法或属性被声明为private（私有的）时，子类是不可以继承的。



子类继承父类的注意事项：

1、在子类中可以继承父类的哪些东西，哪些不可以继承

父类中public、protected修饰的属性和方法可以继承，private修饰的属性和方法不能被继承

2、规则：创建子类对象的时候，首先调用的是父类的无参构造方法创建一个父类对象

3、可以在子类中显示调用父类的有参构造方法

4、如果父类的属性均为private修饰，则可以通过共有的getter、setter方法来调用

# 反射机制 Reflect

正常步骤我们是import"包.类"然后通过new实例化最后得到实例化对象

那么能否反过来呢

从实例化对象得到getClass方法最后得到完整的"包.类"名称

这个反过来的操作(根据实例化对象得到完整的"包.类"名称)就是所谓的反射操作(当然反射的作用不仅仅是得到完整的"包.类"名称)



# 函数式接口



# 自定义参数解析 HandlerMethodArgumentResolver 





# 引用类型、基本类型、包装类型

 str1.equals(str2)的方式，将比较两个字符串的值是否相等

==号，根据JDK的说明，只有在两个引用都指向了同一个对象时才返回真值。

##  引用类型

 **5种引用类型（对象类型）：类 接口 数组 枚举 标注**

堆内存中开辟存储空间，存储引用类型数据

栈内存中存储指向堆内存的空间地址

Test test=new Test();

Test test1=test;

### 对象赋值

栈内存空间地址给新的test1栈内存空间，指向相同的堆内存

## 基本类型、包装类型

### 基本类型

java的基本数据类型共有8种，即int,short,long,byte,float,double,boolean,char

栈内存中存储基本类型的数据，如果存在则直接指向，不存在则开辟新空间，存储新数据。

### 包装类型

Java是一个面向对象的语言，基本类型并不具有对象的性质，为了与其他对象“接轨”就出现了包装类型（如我们在使用集合类型Collection时就一定要使用包装类型而非基本类型），它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。

byte → Byte

short → Short

int → Integer

long → Long

float → Float

double → Double

char → Character

boolean→ Boolean

Java的8种基本类型(Byte, Short, Integer, Long, Character, Boolean, Float, Double), 除Float和Double以外(**因为Double类的valueOf方法会采用与Integer类的valueOf方法不同的实现。很简单：在某个范围内的整型数值的个数是有限的，而浮点数却不是。**), 其它六种都实现了常量池, 但是它们只在大于等于-128并且小于等于127时才使用常量池。



**我思考可能是小于127自动拆箱为int，但看过源码有一个IntegerCache的概念，所以不是小于127自动拆箱，是Integer有自己的常量池 IntegerCache**

```java
Integer a = 200;
System.out.println(a == 200);//true
```

此处a大于127, 返回了 new Integer(i)，成为了一个新的对象，但是 a==200后面的200为int，基本类型，在此处a从Integer拆箱为int基本类型

```java
public static Integer valueOf(int i) {    
    if (i >= IntegerCache.low && i <= IntegerCache.high)        return IntegerCache.cache[i + (-IntegerCache.low)];    return new Integer(i);}
```

#### 包装类型的内存分配和引用类型不同

每次为包装类型赋值，若堆内存中不存在，则开辟新的内存空间，新的栈内存引用

### 拆箱与装箱

包装类型与基本类型的转化

在jdk1.5及以后，自动装箱拆箱

# 操作符

### 逻辑操作符

逻辑 与或非  只可应用于布尔值

​		&&  ||  ！

### 按位运算符

按位  与 或   异或  非

​		&     | 		 ^ 	~

与 或 异或  **二元操作符**

非  **一元操作符**



我们将布尔类型作为一种单比特值对待，所以它多少有些独特，我们可以对他执行按位  **与 或 异或** 预算，但不能执行按位  **非**（大概是为了避免与逻辑NOT混淆）。对于布尔值按位操作与具有与逻辑操作符相同的效果，只是他们不会中途**短路**

### 移位操作符

移位操作符操作的运算对象也是二进制的“位”，移位操作符只可用来处理整数类型

#### 短路

一旦能够明确无误的确定整个表达式的值，就不在计算余下的部分



### 三元操作符

也称作条件运算符

因为有三个操作数，成为三元操作符

boolean-exp : value0 ? value1

### 类型转换操作符

**类型转换(cast)** 的原意是**"模型铸造"**,在适当的时候，java会将一种数据类型自动转换成另一种。

```java
int i=100;
long lng=(long) i
```

这里可能引入了**"多余"**的类型转换,编译器在必要的时候会自动进行int值到long值的提升。但是你仍然可以做这样**多余**的事情，以便提醒自己需要留意，也可使代码更加清楚

#### 窄化转换

窄化转换（**将能容纳更多信息的数据类型转换成无法容纳那么多信息的类型**）会面临信息丢失的危险，此时编译器会强制我们进行类型转换。

#### 扩展转换

不必显示的进行类型转换，因为新类型肯定能容纳原来类型的信息，不会造成任何信息的丢失。

java允许我们把任何基本数据类型转换成别的基本数据类型，但布尔型除外，后者不允许进行任何类型的转换处理



### 截尾和舍入

#### 截尾

​	float或double转型为整型值时，总是对该数字进行截尾，如29.7f转换为int ，值为 29；

#### 舍入

java.lang.Math中的round()方法



# 初始化与清理



# String

String是引用类型，使用字符串缓冲池来存储数据

# final

理解final问题有很重要的含义。许多程序漏洞都基于此—-final只能保证引用永远指向固定对象，不能保证那个对象的状态不变。在多线程的操作中，一个对象会被多个线程共享或修改，一个线程对对象无意识的修改可能会导致另一个使用此对象的线程崩溃。一个错误的解决方法就是在此对象新建的时候把它声明为final，意图使得它”永远不变”。其实那是徒劳的.