



### int数据溢出



```java
//MAX_VALUE
Integer.MAX_VALUE;//2147483647
Integer.MAX_VALUE+1;//-2147483648
Integer.MAX_VALUE+2;//-2147483647
//MIN_VALUE
Integer.MIN_VALUE;//-2147483648
Integer.MIN_VALUE-1;//2147483647
Integer.MIN_VALUE-2;//2147483646
```

```java
/*eg:1*/
int num = 2147483647 ;
num += 2L ; //+=运算符在eg:2中做个一个类型转换，相当于num = (int)(num + 2L);
System.out.println(num) ; 
-2147483647

/*eg:2*/
int num = 2147483647 ;
num = num + 2L ;  //在此处Error:(9, 19) java: 不兼容的类型: 从long转换到int可能会有损失
System.out.println(num) ;

/*eg:3*** 与eg:1实现的过程相同*/
int num = 2147483647 ;
long numB =(int)(2147483649L) ;
System.out.println(numB) ;
-2147483647
```

#### 使用Long类型解决int类型的溢出(数据类型由小变大)

- 问题1：程序的执行顺序都是从等号的右边到左边,Integer.MAX_VALUE+1先计算，得出结果 -2147483648赋值给num，所以num值依旧为-2147483648
  ```java
  long num=Integer.MAX_VALUE+1;
  -2147483648
  ```
  

最简单的做法是将其中一个变量首先做类型的扩充。扩充有两种实现方式

- 将int的数据变量赋值给long
  
    ```java
            long num=Integer.MAX_VALUE;
    //num是long类型+1为int类型=long类型
    		num=num+1;
            System.out.println(num+1);
    2147483648
    ```
  
  - 直接将等号右侧某个int类型变为long类型
  
    ​	 long类型+int类型=long类型
  
    ```java
    long num=(long)Integer.MAX_VALUE+1;
    System.out.println(num);
    2147483648
    ```

#### 数据类型由大变小(强制转换，可能会丢失内容)

```java
long num=2147483647;
//但如果数字超过Integer.MAX_VALUE，即2147483647，则需要在数字后面加上'L'或'l'
long num=2147483648L;
/************************/

long num=2147483648L;
int temp=(int)num;
System.out.println(temp);
-2147483648
```

- 范围小的数据类型可以自动变为范围大的数据类型
- 数据范围大的数据类型只有强制转换才能变为数据范围小的数据类型

### 基本数据类型默认值问题

​		基本数据类型都有其默认值，但是这个默认值在方法的声明中（主方法）无效

```java
public class DataOverflow {
    public static void main(String args[]) {
        int num;
        System.out.println(num);
    }
}
//Error:(9, 28) java: 可能尚未初始化变量num
```

- 1：在使用变量前进行赋值
- 2：在初始化赋值

### 选择题

*下面关于Java程序编写描述正确的一项是？* B

A. Java程序直接利用javac.exe命令就可以直接运行程序

B. 一个Java文件中可以定义有多个class声明，并且类名称可以与文件名称同名

C. 一个Java文件可以使用public class定义多个程序类

D. Java文件的后缀必须使用“*.javac”



### ++i与i++



- ++i,先进行自增，后进行运算
- i++,先进行运算，后进行自增

```java
int num = 50 ;
num = num ++ * 2 ;//在这里进行运算，50*2=100，num=100，而等号右侧的num++中的num则作为临时变量，不会影响外部的num变量
System.out.println(num) ;
```

```java
class Happy {
	public static void main(String args[]) {
      int i = 1 ;    
      int j = i++ ;
      if((i==(++j))&&((i++)==j)){
           i += j ;
       }
       System.out.println("i = "+i);
     }
}
5
```



### instanceof

　instanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例，用法为：

```java
`boolean` `result = obj ``instanceof` `Class`
```

　　其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。

　　注意：编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。

- obj 必须为引用类型，不能是基本类型

  ```java
  int i = 0;
  System.out.println(i instanceof Integer);//编译不通过
  System.out.println(i instanceof Object);//编译不通过
  ```

- obj 为 null

  ```java
  `System.out.println(``null` `instanceof` `Object);``//false`
  ```

  　　关于 null 类型的描述在官方文档：https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.1 有一些介绍。一般我们知道Java分为两种数据类型，一种是基本数据类型，有八个分别是 byte  short  int  long  float  double  char boolean,一种是引用类型，包括类，接口，数组等等。而Java中还有一种特殊的 null 类型，该类型没有名字，所以不可能声明为 null 类型的变量或者转换为 null 类型，null 引用是 null 类型表达式唯一可能的值，null 引用也可以转换为任意引用类型。我们不需要对 null 类型有多深刻的了解，我们只需要知道 null 是可以成为任意引用类型的**特殊符号**。

  　　在 [JavaSE规范](https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.20.2) 中对 instanceof 运算符的规定就是：如果 obj 为 null，那么将返回 false。

### static与final



# 继承

## 子类不能直接访问父类的私有属性

首先子类是无法继承父类的私有属性，也无法直接访问父类的私有属性。

但如果父类中有对私有属性的get和set的方法，而且是public的修饰的方法，

子类在继承父类的同时，也继承了带有public修饰的set和get方法，所以可以通过以下方式子类可以访问到父类的私有属性。



子类继承父类的所有的非私有的方法和属性。当父类的方法或属性被声明为private（私有的）时，子类是不可以继承的。



子类继承父类的注意事项：

1、在子类中可以继承父类的哪些东西，哪些不可以继承

父类中public、protected修饰的属性和方法可以继承，private修饰的属性和方法不能被继承

2、规则：创建子类对象的时候，首先调用的是父类的无参构造方法创建一个父类对象

3、可以在子类中显示调用父类的有参构造方法

4、如果父类的属性均为private修饰，则可以通过共有的getter、setter方法来调用

# 反射机制 Reflect

正常步骤我们是import"包.类"然后通过new实例化最后得到实例化对象

那么能否反过来呢

从实例化对象得到getClass方法最后得到完整的"包.类"名称

这个反过来的操作(根据实例化对象得到完整的"包.类"名称)就是所谓的反射操作(当然反射的作用不仅仅是得到完整的"包.类"名称)



# 函数式接口



# 自定义参数解析 HandlerMethodArgumentResolver 





# 引用类型、基本类型、包装类型

 str1.equals(str2)的方式，将比较两个字符串的值是否相等

==号，根据JDK的说明，只有在两个引用都指向了同一个对象时才返回真值。

##  引用类型

 **5种引用类型（对象类型）：类 接口 数组 枚举 标注**

堆内存中开辟存储空间，存储引用类型数据

栈内存中存储指向堆内存的空间地址

Test test=new Test();

Test test1=test;

### 对象赋值

栈内存空间地址给新的test1栈内存空间，指向相同的堆内存

## 基本类型、包装类型

### 基本类型

java的基本数据类型共有8种，即int,short,long,byte,float,double,boolean,char

栈内存中存储基本类型的数据，如果存在则直接指向，不存在则开辟新空间，存储新数据。

### 包装类型

Java是一个面向对象的语言，基本类型并不具有对象的性质，为了与其他对象“接轨”就出现了包装类型（如我们在使用集合类型Collection时就一定要使用包装类型而非基本类型），它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。

byte → Byte

short → Short

int → Integer

long → Long

float → Float

double → Double

char → Character

boolean→ Boolean

Java的8种基本类型(Byte, Short, Integer, Long, Character, Boolean, Float, Double), 除Float和Double以外(**因为Double类的valueOf方法会采用与Integer类的valueOf方法不同的实现。很简单：在某个范围内的整型数值的个数是有限的，而浮点数却不是。**), 其它六种都实现了常量池, 但是它们只在大于等于-128并且小于等于127时才使用常量池。



**我思考可能是小于127自动拆箱为int，但看过源码有一个IntegerCache的概念，所以不是小于127自动拆箱，是Integer有自己的常量池 IntegerCache**

```java
Integer a = 200;
System.out.println(a == 200);//true
```

此处a大于127, 返回了 new Integer(i)，成为了一个新的对象，但是 a==200后面的200为int，基本类型，在此处a从Integer拆箱为int基本类型

```java
public static Integer valueOf(int i) {    
    if (i >= IntegerCache.low && i <= IntegerCache.high)        return IntegerCache.cache[i + (-IntegerCache.low)];    return new Integer(i);}
```

#### 包装类型的内存分配和引用类型不同

每次为包装类型赋值，若堆内存中不存在，则开辟新的内存空间，新的栈内存引用

### 拆箱与装箱

包装类型与基本类型的转化

在jdk1.5及以后，自动装箱拆箱

# String

String是引用类型，使用字符串缓冲池来存储数据

# final

理解final问题有很重要的含义。许多程序漏洞都基于此—-final只能保证引用永远指向固定对象，不能保证那个对象的状态不变。在多线程的操作中，一个对象会被多个线程共享或修改，一个线程对对象无意识的修改可能会导致另一个使用此对象的线程崩溃。一个错误的解决方法就是在此对象新建的时候把它声明为final，意图使得它”永远不变”。其实那是徒劳的.